<!-- udacimak v1.4.4 -->
<!DOCTYPE html>
<html lang="en">
 <head>
  <meta charset="utf-8"/>
  <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
  <meta content="ie=edge" http-equiv="X-UA-Compatible"/>
  <title>
   Linear Transform
  </title>
  <link href="../assets/css/bootstrap.min.css" rel="stylesheet"/>
  <link href="../assets/css/plyr.css" rel="stylesheet"/>
  <link href="../assets/css/katex.min.css" rel="stylesheet"/>
  <link href="../assets/css/jquery.mCustomScrollbar.min.css" rel="stylesheet"/>
  <link href="../assets/css/styles.css" rel="stylesheet"/>
  <link href="../assets/img/udacimak.png" rel="shortcut icon" type="image/png">
  </link>
 </head>
 <body>
  <div class="wrapper">
   <nav id="sidebar">
    <div class="sidebar-header">
     <h3>
      MiniFlow
     </h3>
    </div>
    <ul class="sidebar-list list-unstyled CTAs">
     <li>
      <a class="article" href="../index.html">
       Back to Home
      </a>
     </li>
    </ul>
    <ul class="sidebar-list list-unstyled components">
     <li class="">
      <a href="01. Welcome to MiniFlow.html">
       01. Welcome to MiniFlow
      </a>
     </li>
     <li class="">
      <a href="02. Graphs.html">
       02. Graphs
      </a>
     </li>
     <li class="">
      <a href="03. MiniFlow Architecture.html">
       03. MiniFlow Architecture
      </a>
     </li>
     <li class="">
      <a href="04. Forward Propagation.html">
       04. Forward Propagation
      </a>
     </li>
     <li class="">
      <a href="05. Forward Propagation Solution.html">
       05. Forward Propagation Solution
      </a>
     </li>
     <li class="">
      <a href="06. Learning and Loss.html">
       06. Learning and Loss
      </a>
     </li>
     <li class="">
      <a href="07. Linear Transform.html">
       07. Linear Transform
      </a>
     </li>
     <li class="">
      <a href="08. Sigmoid Function.html">
       08. Sigmoid Function
      </a>
     </li>
     <li class="">
      <a href="09. Cost.html">
       09. Cost
      </a>
     </li>
     <li class="">
      <a href="10. Cost Solution.html">
       10. Cost Solution
      </a>
     </li>
     <li class="">
      <a href="11. Gradient Descent.html">
       11. Gradient Descent
      </a>
     </li>
     <li class="">
      <a href="12. Backpropagation.html">
       12. Backpropagation
      </a>
     </li>
     <li class="">
      <a href="13. Stochastic Gradient Descent.html">
       13. Stochastic Gradient Descent
      </a>
     </li>
     <li class="">
      <a href="14. SGD Solution.html">
       14. SGD Solution
      </a>
     </li>
     <li class="">
      <a href="15. Outro.html">
       15. Outro
      </a>
     </li>
    </ul>
    <ul class="sidebar-list list-unstyled CTAs">
     <li>
      <a class="article" href="../index.html">
       Back to Home
      </a>
     </li>
    </ul>
   </nav>
   <div id="content">
    <header class="container-fluild header">
     <div class="container">
      <div class="row">
       <div class="col-12">
        <div class="align-items-middle">
         <button class="btn btn-toggle-sidebar" id="sidebarCollapse" type="button">
          <div>
          </div>
          <div>
          </div>
          <div>
          </div>
         </button>
         <h1 style="display: inline-block">
          07. Linear Transform
         </h1>
        </div>
       </div>
      </div>
     </div>
    </header>
    <main class="container">
     <div class="row">
      <div class="col-12">
       <div class="ud-atom">
        <h3>
        </h3>
        <div>
         <h4 id="solution-to-linear-node">
          Solution to Linear Node
         </h4>
         <p>
          Here's my solution to the last quiz:
         </p>
         <pre><code>class Linear(Node):
    def __init__(self, inputs, weights, bias):
        Node.__init__(self, [inputs, weights, bias])

    def forward(self):
        """
        Set self.value to the value of the linear function output.

        Your code goes here!
        """
        inputs = self.inbound_nodes[0].value
        weights = self.inbound_nodes[1].value
        bias = self.inbound_nodes[2]
        self.value = bias.value
        for x, w in zip(inputs, weights):
            self.value += x * w</code></pre>
         <p>
          In the solution, I set
          <code>
           self.value
          </code>
          to the bias and then loop through the inputs and weights, adding each weighted input to
          <code>
           self.value
          </code>
          . Notice calling
          <code>
           .value
          </code>
          on
          <code>
           self.inbound_nodes[0]
          </code>
          or
          <code>
           self.inbound_nodes[1]
          </code>
          gives us a list.
         </p>
        </div>
       </div>
       <div class="divider">
       </div>
       <div class="ud-atom">
        <h3>
        </h3>
        <div>
         <figure class="figure">
          <img alt="Shift your thinking here to the edges between layers." class="img img-fluid" src="img/screen-shot-2016-10-21-at-15.43.05.png"/>
          <figcaption class="figure-caption">
           <p>
            Shift your thinking here to the edges between layers.
           </p>
          </figcaption>
         </figure>
        </div>
       </div>
       <div class="divider">
       </div>
       <div class="ud-atom">
        <h3>
        </h3>
        <div>
         <p>
          <a href="https://www.khanacademy.org/math/linear-algebra" rel="noopener noreferrer" target="_blank">
           Linear algebra
          </a>
          nicely reflects the idea of transforming values between layers in a graph. In fact, the concept of a
          <a href="https://www.khanacademy.org/math/linear-algebra/matrix-transformations/linear-transformations/v/vector-transformations" rel="noopener noreferrer" target="_blank">
           transform
          </a>
          does exactly what a layer should do - it converts inputs to outputs in many dimensions.
         </p>
         <p>
          Let's go back to our equation for the output.
         </p>
        </div>
       </div>
       <div class="divider">
       </div>
       <div class="ud-atom">
        <h3>
        </h3>
        <div>
         <figure class="figure">
          <img alt="Equation (1)" class="img img-fluid" src="img/neuron-output.png"/>
          <figcaption class="figure-caption">
           <p>
            Equation (1)
           </p>
          </figcaption>
         </figure>
        </div>
       </div>
       <div class="divider">
       </div>
       <div class="ud-atom">
        <h3>
        </h3>
        <div>
         <p>
          For the rest of this section we'll denote
          <em>
           x
          </em>
          as
          <em>
           X
          </em>
          and
          <em>
           w
          </em>
          as
          <em>
           W
          </em>
          since they are now matrices, and
          <em>
           b
          </em>
          is now a vector instead of a scalar.
         </p>
         <p>
          Consider a
          <code>
           Linear
          </code>
          node with 1 input and k outputs (mapping 1 input to k outputs). In this context an input/output is synonymous with a feature.
         </p>
         <p>
          In this case
          <em>
           X
          </em>
          is a 1 by 1 matrix.
         </p>
        </div>
       </div>
       <div class="divider">
       </div>
       <div class="ud-atom">
        <h3>
        </h3>
        <div>
         <figure class="figure">
          <img alt="1 by 1 matrix, 1 element." class="img img-fluid" src="img/newx.png"/>
          <figcaption class="figure-caption">
           <p>
            1 by 1 matrix, 1 element.
           </p>
          </figcaption>
         </figure>
        </div>
       </div>
       <div class="divider">
       </div>
       <div class="ud-atom">
        <h3>
        </h3>
        <div>
         <p>
          <em>
           W
          </em>
          becomes a 1 by k matrix (looks like a row).
         </p>
        </div>
       </div>
       <div class="divider">
       </div>
       <div class="ud-atom">
        <h3>
        </h3>
        <div>
         <figure class="figure">
          <img alt="A 1 by k weights row matrix." class="img img-fluid" src="img/neww.png"/>
          <figcaption class="figure-caption">
           <p>
            A 1 by k weights row matrix.
           </p>
          </figcaption>
         </figure>
        </div>
       </div>
       <div class="divider">
       </div>
       <div class="ud-atom">
        <h3>
        </h3>
        <div>
         <p>
          The result of the matrix multiplication of
          <em>
           X
          </em>
          and
          <em>
           W
          </em>
          is a 1 by k matrix. Since
          <em>
           b
          </em>
          is also a 1 by k row matrix (1 bias per output),
          <em>
           b
          </em>
          is added to the output of the
          <em>
           X
          </em>
          and
          <em>
           W
          </em>
          matrix multiplication.
         </p>
         <p>
          What if we are mapping n inputs to k outputs?
         </p>
         <p>
          Then
          <em>
           X
          </em>
          is now a 1 by n matrix and
          <em>
           W
          </em>
          is a n by k matrix. The result of the matrix multiplication is still a 1 by k matrix so the use of the biases remain the same.
         </p>
        </div>
       </div>
       <div class="divider">
       </div>
       <div class="ud-atom">
        <h3>
        </h3>
        <div>
         <figure class="figure">
          <img alt="X is now a 1 by n matrix, n inputs/features." class="img img-fluid" src="img/newx-1n.png"/>
          <figcaption class="figure-caption">
           <p>
            X is now a 1 by n matrix, n inputs/features.
           </p>
          </figcaption>
         </figure>
        </div>
       </div>
       <div class="divider">
       </div>
       <div class="ud-atom">
        <h3>
        </h3>
        <div>
         <figure class="figure">
          <img alt="" class="img img-fluid" src="img/neww-nk-fixed.gif"/>
          <figcaption class="figure-caption">
          </figcaption>
         </figure>
        </div>
       </div>
       <div class="divider">
       </div>
       <div class="ud-atom">
        <h3>
        </h3>
        <div>
         <figure class="figure">
          <img alt="Row matrix of biases, one for each output." class="img img-fluid" src="img/b-1byk.png"/>
          <figcaption class="figure-caption">
           <p>
            Row matrix of biases, one for each output.
           </p>
          </figcaption>
         </figure>
        </div>
       </div>
       <div class="divider">
       </div>
       <div class="ud-atom">
        <h3>
        </h3>
        <div>
         <p>
          Let's take a look at an example of n inputs. Consider an 28px by 28px greyscale image, as is in the case of images in the
          <a href="http://yann.lecun.com/exdb/mnist/" rel="noopener noreferrer" target="_blank">
           MNIST dataset
          </a>
          , a set of handwritten digits. We can reshape the image such that it's a 1 by 784 matrix, n = 784.  Each pixel is an input/feature. Here's an animated example emphasizing a pixel is a feature.
         </p>
        </div>
       </div>
       <div class="divider">
       </div>
       <div class="ud-atom">
        <h3>
         <p>
          Pixels are Features!
         </p>
        </h3>
        <video controls="">
         <source src="07. Pixels are Features!-qE5YYXtPq9U.mp4" type="video/mp4"/>
         <track default="true" kind="subtitles" label="en-US" src="07. Pixels are Features!-qE5YYXtPq9U.en-US.vtt" srclang="en-US"/>
         <track default="false" kind="subtitles" label="pt-BR" src="07. Pixels are Features!-qE5YYXtPq9U.pt-BR.vtt" srclang="pt-BR"/>
        </video>
       </div>
       <div class="divider">
       </div>
       <div class="ud-atom">
        <h3>
        </h3>
        <div>
         <p>
          In practice, it's common to feed in multiple data examples in each forward pass rather than just 1. The reasoning for this is the examples can be processed in parallel, resulting in big performance gains. The number of examples is called the
          <em>
           batch size
          </em>
          . Common numbers for the batch size are 32, 64, 128, 256, 512. Generally, it's the most we can comfortably fit in memory.
         </p>
         <p>
          What does this mean for
          <em>
           X
          </em>
          ,
          <em>
           W
          </em>
          and
          <em>
           b
          </em>
          ?
         </p>
         <p>
          <em>
           X
          </em>
          becomes a m by n matrix and
          <em>
           W
          </em>
          and
          <em>
           b
          </em>
          remain the same. The result of the matrix multiplication is now m by k, so the addition of
          <em>
           b
          </em>
          is
          <a href="https://docs.scipy.org/doc/numpy/user/basics.broadcasting.html" rel="noopener noreferrer" target="_blank">
           broadcast
          </a>
          over each row.
         </p>
        </div>
       </div>
       <div class="divider">
       </div>
       <div class="ud-atom">
        <h3>
        </h3>
        <div>
         <figure class="figure">
          <img alt="X is now an m by n matrix. Each row has n inputs/features." class="img img-fluid" src="img/x-mn.png"/>
          <figcaption class="figure-caption">
           <p>
            X is now an m by n matrix. Each row has n inputs/features.
           </p>
          </figcaption>
         </figure>
        </div>
       </div>
       <div class="divider">
       </div>
       <div class="ud-atom">
        <h3>
        </h3>
        <div>
         <p>
          In the context of MNIST each row  of
          <em>
           X
          </em>
          is an image reshaped from 28 by 28 to 1 by 784.
         </p>
        </div>
       </div>
       <div class="divider">
       </div>
       <div class="ud-atom">
        <h3>
        </h3>
        <div>
         <figure class="figure">
          <img alt="Equation (2)" class="img img-fluid" src="img/z.png"/>
          <figcaption class="figure-caption">
           <p>
            Equation (2)
           </p>
          </figcaption>
         </figure>
        </div>
       </div>
       <div class="divider">
       </div>
       <div class="ud-atom">
        <h3>
        </h3>
        <div>
         <p>
          Equation (2) can also be viewed as
          <em>
           Z = XW + B
          </em>
          where
          <em>
           B
          </em>
          is the biases vector,
          <em>
           b
          </em>
          , stacked m times as a row. Due to broadcasting it's abbreviated to
          <em>
           Z = XW + b
          </em>
          .
         </p>
        </div>
       </div>
       <div class="divider">
       </div>
       <div class="ud-atom">
        <h3>
        </h3>
        <div>
         <p>
          I want you to rebuild
          <code>
           Linear
          </code>
          to handle matrices and vectors using the venerable Python math package
          <code>
           numpy
          </code>
          to make your life easier.
          <code>
           numpy
          </code>
          is often abbreviated as
          <code>
           np
          </code>
          , so we'll refer to it as
          <code>
           np
          </code>
          when referring to code.
         </p>
         <p>
          I used
          <code>
           np.array
          </code>
          (
          <a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.array.html" rel="noopener noreferrer" target="_blank">
           documentation
          </a>
          ) to create the matrices and vectors. You'll want to use
          <code>
           np.dot
          </code>
          , which functions as matrix multiplication for 2D arrays (
          <a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.dot.html" rel="noopener noreferrer" target="_blank">
           documentation
          </a>
          ), to multiply the input and weights matrices from Equation (2). It's also worth noting that numpy actually overloads the
          <code>
           __add__
          </code>
          operator so you can use it directly with
          <code>
           np.array
          </code>
          (eg.
          <code>
           np.array() + np.array()
          </code>
          ).
         </p>
         <h3 id="instructions">
          Instructions
         </h3>
         <ol>
          <li>
           Open nn.py. See how the neural network implements the
           <code>
            Linear
           </code>
           node.
          </li>
          <li>
           Open miniflow.py. Implement Equation (2) within the forward pass for the
           <code>
            Linear
           </code>
           node.
          </li>
          <li>
           Test your work!
          </li>
         </ol>
        </div>
       </div>
       <div class="divider">
       </div>
       <div class="ud-atom">
        <h3>
        </h3>
        <div>
         <h4>
          Start Quiz:
         </h4>
         <div>
          <div class="nav nav-tabs nav-fill" id="question-tabs" role="tablist">
           <a aria-controls="262904-nn-py" aria-selected="true" class="nav-item nav-link active show" data-toggle="tab" href="#262904-nn-py" id="tab-262904-nn-py" role="tab">
            nn.py
           </a>
           <a aria-controls="262904-miniflow-py" aria-selected="false" class="nav-item nav-link" data-toggle="tab" href="#262904-miniflow-py" id="tab-262904-miniflow-py" role="tab">
            miniflow.py
           </a>
          </div>
          <div class="tab-content" id="question-tab-contents" style="padding: 20px 0;">
           <div aria-labelledby="tab-262904-nn-py" class="tab-pane active show" id="262904-nn-py" role="tabpanel">
            <pre><code></code>"""
The setup is similar to the prevous `Linear` node you wrote
except you're now using NumPy arrays instead of python lists.

Update the Linear class in miniflow.py to work with
numpy vectors (arrays) and matrices.

Test your code here!
"""

import numpy as np
from miniflow import *

X, W, b = Input(), Input(), Input()

f = Linear(X, W, b)

X_ = np.array([[-1., -2.], [-1, -2]])
W_ = np.array([[2., -3], [2., -3]])
b_ = np.array([-3., -5])

feed_dict = {X: X_, W: W_, b: b_}

graph = topological_sort(feed_dict)
output = forward_pass(f, graph)

"""
Output should be:
[[-9., 4.],
[-9., 4.]]
"""
print(output)</pre>
           </div>
           <div aria-labelledby="tab-262904-miniflow-py" class="tab-pane" id="262904-miniflow-py" role="tabpanel">
            <pre><code></code>"""
Modify Linear#forward so that it linearly transforms
input matrices, weights matrices and a bias vector to
an output.
"""

import numpy as np


class Node(object):
    def __init__(self, inbound_nodes=[]):
        self.inbound_nodes = inbound_nodes
        self.value = None
        self.outbound_nodes = []
        for node in inbound_nodes:
            node.outbound_nodes.append(self)

    def forward():
        raise NotImplementedError


class Input(Node):
    """
    While it may be strange to consider an input a node when
    an input is only an individual node in a node, for the sake
    of simpler code we'll still use Node as the base class.

    Think of Input as collating many individual input nodes into
    a Node.
    """
    def __init__(self):
        # An Input node has no inbound nodes,
        # so no need to pass anything to the Node instantiator
        Node.__init__(self)

    def forward(self):
        # Do nothing because nothing is calculated.
        pass


class Linear(Node):
    def __init__(self, X, W, b):
        # Notice the ordering of the input nodes passed to the
        # Node constructor.
        Node.__init__(self, [X, W, b])

    def forward(self):
        """
        Set the value of this node to the linear transform output.

        Your code goes here!
        """


def topological_sort(feed_dict):
    """
    Sort the nodes in topological order using Kahn's Algorithm.

    `feed_dict`: A dictionary where the key is a `Input` Node and the value is the respective value feed to that Node.

    Returns a list of sorted nodes.
    """

    input_nodes = [n for n in feed_dict.keys()]

    G = {}
    nodes = [n for n in input_nodes]
    while len(nodes) &gt; 0:
        n = nodes.pop(0)
        if n not in G:
            G[n] = {'in': set(), 'out': set()}
        for m in n.outbound_nodes:
            if m not in G:
                G[m] = {'in': set(), 'out': set()}
            G[n]['out'].add(m)
            G[m]['in'].add(n)
            nodes.append(m)

    L = []
    S = set(input_nodes)
    while len(S) &gt; 0:
        n = S.pop()

        if isinstance(n, Input):
            n.value = feed_dict[n]

        L.append(n)
        for m in n.outbound_nodes:
            G[n]['out'].remove(m)
            G[m]['in'].remove(n)
            # if no other incoming edges add to S
            if len(G[m]['in']) == 0:
                S.add(m)
    return L


def forward_pass(output_node, sorted_nodes):
    """
    Performs a forward pass through a list of sorted Nodes.

    Arguments:

        `output_node`: A Node in the graph, should be the output node (have no outgoing edges).
        `sorted_nodes`: a topologically sorted list of nodes.

    Returns the output node's value
    """

    for n in sorted_nodes:
        n.forward()

    return output_node.value</pre>
           </div>
          </div>
         </div>
        </div>
       </div>
       <div class="divider">
       </div>
      </div>
      <div class="col-12">
       <p class="text-right">
        <a class="btn btn-outline-primary mt-4" href="08. Sigmoid Function.html" role="button">
         Next Concept
        </a>
       </p>
      </div>
     </div>
    </main>
    <footer class="footer">
     <div class="container">
      <div class="row">
       <div class="col-12">
        <p class="text-center">
         udacity2.0 If you need the newest courses Plase add me wechat: udacity6
        </p>
       </div>
      </div>
     </div>
    </footer>
   </div>
  </div>
  <script src="../assets/js/jquery-3.3.1.min.js">
  </script>
  <script src="../assets/js/plyr.polyfilled.min.js">
  </script>
  <script src="../assets/js/bootstrap.min.js">
  </script>
  <script src="../assets/js/jquery.mCustomScrollbar.concat.min.js">
  </script>
  <script src="../assets/js/katex.min.js">
  </script>
  <script>
   // Initialize Plyr video players
    const players = Array.from(document.querySelectorAll('video')).map(p => new Plyr(p));

    // render math equations
    let elMath = document.getElementsByClassName('mathquill');
    for (let i = 0, len = elMath.length; i < len; i += 1) {
      const el = elMath[i];

      katex.render(el.textContent, el, {
        throwOnError: false
      });
    }

    // this hack will make sure Bootstrap tabs work when using Handlebars
    if ($('#question-tabs').length && $('#user-answer-tabs').length) {
      $("#question-tabs a.nav-link").on('click', function () {
        $("#question-tab-contents .tab-pane").hide();
        $($(this).attr("href")).show();
      });
      $("#user-answer-tabs a.nav-link").on('click', function () {
        $("#user-answer-tab-contents .tab-pane").hide();
        $($(this).attr("href")).show();
      });
    } else {
      $("a.nav-link").on('click', function () {
        $(".tab-pane").hide();
        $($(this).attr("href")).show();
      });
    }

    // side bar events
    $(document).ready(function () {
      $("#sidebar").mCustomScrollbar({
        theme: "minimal"
      });

      $('#sidebarCollapse').on('click', function () {
        $('#sidebar, #content').toggleClass('active');
        $('.collapse.in').toggleClass('in');
        $('a[aria-expanded=true]').attr('aria-expanded', 'false');
      });

      // scroll to first video on page loading
      if ($('video').length) {
        $('html,body').animate({ scrollTop: $('div.plyr').prev().offset().top});
      }

      // auto play first video: this may not work with chrome/safari due to autoplay policy
      if (players && players.length > 0) {
        players[0].play();
      }

      // scroll sidebar to current concept
      const currentInSideBar = $( "ul.sidebar-list.components li a:contains('07. Linear Transform')" )
      currentInSideBar.css( "text-decoration", "underline" );
      $("#sidebar").mCustomScrollbar('scrollTo', currentInSideBar);
    });
  </script>
 </body>
</html>
