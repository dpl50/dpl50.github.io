<!-- udacimak v1.4.4 -->
<!DOCTYPE html>
<html lang="en">
 <head>
  <meta charset="utf-8"/>
  <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
  <meta content="ie=edge" http-equiv="X-UA-Compatible"/>
  <title>
   Backpropagation
  </title>
  <link href="../assets/css/bootstrap.min.css" rel="stylesheet"/>
  <link href="../assets/css/plyr.css" rel="stylesheet"/>
  <link href="../assets/css/katex.min.css" rel="stylesheet"/>
  <link href="../assets/css/jquery.mCustomScrollbar.min.css" rel="stylesheet"/>
  <link href="../assets/css/styles.css" rel="stylesheet"/>
  <link href="../assets/img/udacimak.png" rel="shortcut icon" type="image/png">
  </link>
 </head>
 <body>
  <div class="wrapper">
   <nav id="sidebar">
    <div class="sidebar-header">
     <h3>
      MiniFlow
     </h3>
    </div>
    <ul class="sidebar-list list-unstyled CTAs">
     <li>
      <a class="article" href="../index.html">
       Back to Home
      </a>
     </li>
    </ul>
    <ul class="sidebar-list list-unstyled components">
     <li class="">
      <a href="01. Welcome to MiniFlow.html">
       01. Welcome to MiniFlow
      </a>
     </li>
     <li class="">
      <a href="02. Graphs.html">
       02. Graphs
      </a>
     </li>
     <li class="">
      <a href="03. MiniFlow Architecture.html">
       03. MiniFlow Architecture
      </a>
     </li>
     <li class="">
      <a href="04. Forward Propagation.html">
       04. Forward Propagation
      </a>
     </li>
     <li class="">
      <a href="05. Forward Propagation Solution.html">
       05. Forward Propagation Solution
      </a>
     </li>
     <li class="">
      <a href="06. Learning and Loss.html">
       06. Learning and Loss
      </a>
     </li>
     <li class="">
      <a href="07. Linear Transform.html">
       07. Linear Transform
      </a>
     </li>
     <li class="">
      <a href="08. Sigmoid Function.html">
       08. Sigmoid Function
      </a>
     </li>
     <li class="">
      <a href="09. Cost.html">
       09. Cost
      </a>
     </li>
     <li class="">
      <a href="10. Cost Solution.html">
       10. Cost Solution
      </a>
     </li>
     <li class="">
      <a href="11. Gradient Descent.html">
       11. Gradient Descent
      </a>
     </li>
     <li class="">
      <a href="12. Backpropagation.html">
       12. Backpropagation
      </a>
     </li>
     <li class="">
      <a href="13. Stochastic Gradient Descent.html">
       13. Stochastic Gradient Descent
      </a>
     </li>
     <li class="">
      <a href="14. SGD Solution.html">
       14. SGD Solution
      </a>
     </li>
     <li class="">
      <a href="15. Outro.html">
       15. Outro
      </a>
     </li>
    </ul>
    <ul class="sidebar-list list-unstyled CTAs">
     <li>
      <a class="article" href="../index.html">
       Back to Home
      </a>
     </li>
    </ul>
   </nav>
   <div id="content">
    <header class="container-fluild header">
     <div class="container">
      <div class="row">
       <div class="col-12">
        <div class="align-items-middle">
         <button class="btn btn-toggle-sidebar" id="sidebarCollapse" type="button">
          <div>
          </div>
          <div>
          </div>
          <div>
          </div>
         </button>
         <h1 style="display: inline-block">
          12. Backpropagation
         </h1>
        </div>
       </div>
      </div>
     </div>
    </header>
    <main class="container">
     <div class="row">
      <div class="col-12">
       <div class="ud-atom">
        <h3>
        </h3>
        <div>
         <h3 id="gradient-descent-solution">
          Gradient Descent Solution
         </h3>
         <pre><code class="python language-python">def gradient_descent_update(x, gradx, learning_rate):
    """
    Performs a gradient descent update.
    """
    x = x - learning_rate * gradx
    # Return the new value for x
    return x</code></pre>
         <p>
          We adjust the old
          <code>
           x
          </code>
          pushing it in the
          <em>
           opposite direction
          </em>
          of
          <code>
           gradx
          </code>
          with the
          <em>
           force
          </em>
          <code>
           learning_rate
          </code>
          . Subtracting
          <code>
           learning_rate * gradx
          </code>
          . Remember the gradient is initially in the direction of
          <strong>
           steepest ascent
          </strong>
          so subtracting
          <code>
           learning_rate * gradx
          </code>
          from
          <code>
           x
          </code>
          turns it into
          <strong>
           steepest descent
          </strong>
          . You can make sure of this yourself by replacing the subtraction with an addition.
         </p>
        </div>
       </div>
       <div class="divider">
       </div>
       <div class="ud-atom">
        <h3>
        </h3>
        <div>
         <h3 id="the-gradient--backpropagation">
          The Gradient &amp; Backpropagation
         </h3>
         <p>
          Now that we know how to update our weights and biases using the gradient, we need to figure out how to calculate the gradients for all of our nodes. For each node, we'll want to change the values based on the gradient of the cost with respect to the value of that node. In this way, the gradient descent updates we make will eventually converge to the minimum of the cost.
         </p>
         <p>
          Let's consider a network with a linear node
          <span class="mathquill ud-math">
           l_1
          </span>
          , a sigmoid node
          <span class="mathquill ud-math">
           s
          </span>
          , and another linear node
          <span class="mathquill ud-math">
           l_2
          </span>
          , followed by an MSE node to calculate the cost,
          <span class="mathquill ud-math">
           C
          </span>
          .
         </p>
        </div>
       </div>
       <div class="divider">
       </div>
       <div class="ud-atom">
        <h3>
        </h3>
        <div>
         <figure class="figure">
          <img alt="Forward pass for a simple two layer network." class="img img-fluid" src="img/two-layer-graph.png"/>
          <figcaption class="figure-caption">
           <p>
            Forward pass for a simple two layer network.
           </p>
          </figcaption>
         </figure>
        </div>
       </div>
       <div class="divider">
       </div>
       <div class="ud-atom">
        <h3>
        </h3>
        <div>
         <p>
          Writing this out in MiniFlow, it would look like:
         </p>
         <pre><code class="python language-python">X, y = Input(), Input()
W1, b1 = Input(), Input()
W2, b2 = Input(), Input()

l1 = Linear(X, W1, b1)
s = Sigmoid(l1)
l2 = Linear(s, W2, b2)
cost = MSE(l2, y)</code></pre>
        </div>
       </div>
       <div class="divider">
       </div>
       <div class="ud-atom">
        <h3>
        </h3>
        <div>
         <p>
          We can see that each of the values of these nodes flows forwards and eventually produces the cost
          <span class="mathquill ud-math">
           C
          </span>
          . For example, the value of the second linear node
          <span class="mathquill ud-math">
           l_2
          </span>
          goes into the cost node and determines the value of that node. Accordingly, a
          <em>
           change
          </em>
          in
          <span class="mathquill ud-math">
           l_2
          </span>
          will produce a
          <em>
           change
          </em>
          in
          <span class="mathquill ud-math">
           C
          </span>
          . We can write this relationship between the changes as a gradient,
         </p>
        </div>
       </div>
       <div class="divider">
       </div>
       <div class="ud-atom">
        <h3>
        </h3>
        <div>
         <figure class="figure">
          <img alt="" class="img img-fluid" src="img/dcdl2.png"/>
          <figcaption class="figure-caption">
          </figcaption>
         </figure>
        </div>
       </div>
       <div class="divider">
       </div>
       <div class="ud-atom">
        <h3>
        </h3>
        <div>
         <p>
          This is what a gradient means, it's a slope, how much you change the cost
          <span class="mathquill ud-math">
           \partial C
          </span>
          given a change in
          <span class="mathquill ud-math">
           l_2
          </span>
          ,
          <span class="mathquill ud-math">
           \partial l_2
          </span>
          . So a node with a larger gradient with respect to the cost is going to contribute a larger change to the cost. In this way, we can assign blame for the cost to each node. The larger the gradient for a node, the more blame it gets for the final cost. And the more blame a node has, the more we'll update it in the gradient descent step.
         </p>
         <p>
          If we want to update one of the weights with gradient descent, we'll need the gradient of the cost with respect to those weights. Let's see how we can use this framework to find the gradient for the weights in the second layer,
          <span class="mathquill ud-math">
           w_2
          </span>
          . We want to calculate the gradient of
          <span class="mathquill ud-math">
           C
          </span>
          with respect to
          <span class="mathquill ud-math">
           w_2
          </span>
          :
         </p>
        </div>
       </div>
       <div class="divider">
       </div>
       <div class="ud-atom">
        <h3>
        </h3>
        <div>
         <figure class="figure">
          <img alt="" class="img img-fluid" src="img/dcdw2.png"/>
          <figcaption class="figure-caption">
          </figcaption>
         </figure>
        </div>
       </div>
       <div class="divider">
       </div>
       <div class="ud-atom">
        <h3>
        </h3>
        <div>
         <p>
          We can see in the graph that
          <span class="mathquill ud-math">
           w_2
          </span>
          is connected to
          <span class="mathquill ud-math">
           l_2
          </span>
          , so a change in
          <span class="mathquill ud-math">
           w_2
          </span>
          is going to create a change in
          <span class="mathquill ud-math">
           l_2
          </span>
          which then creates a change in
          <span class="mathquill ud-math">
           C
          </span>
          . We can assign blame to
          <span class="mathquill ud-math">
           w_2
          </span>
          by sending the cost gradient back through the network. First you have how much
          <span class="mathquill ud-math">
           l_2
          </span>
          affected
          <span class="mathquill ud-math">
           C
          </span>
          , then how much
          <span class="mathquill ud-math">
           w_2
          </span>
          affected
          <span class="mathquill ud-math">
           l_2
          </span>
          . Multiplying these gradients together gets you the total blame attributed to
          <span class="mathquill ud-math">
           w_2
          </span>
          .
         </p>
        </div>
       </div>
       <div class="divider">
       </div>
       <div class="ud-atom">
        <h3>
        </h3>
        <div>
         <figure class="figure">
          <img alt="" class="img img-fluid" src="img/w2-backprop-graph.png"/>
          <figcaption class="figure-caption">
          </figcaption>
         </figure>
        </div>
       </div>
       <div class="divider">
       </div>
       <div class="ud-atom">
        <h3>
        </h3>
        <div>
         <h4 id="pre-requisites">
          Pre-requisites
         </h4>
         <p>
          Below we're getting into the math behind backpropagation which requires multivariable calculus. If you need a refresher, I highly recommend checking out
         </p>
         <ul>
          <li>
           <a href="https://www.khanacademy.org/math/multivariable-calculus/multivariable-derivatives/partial-derivatives/v/partial-derivatives-introduction" rel="noopener noreferrer" target="_blank">
            Khan Academy's lessons on partial derivatives
           </a>
          </li>
          <li>
           Another video on
           <a href="https://www.khanacademy.org/math/multivariable-calculus/multivariable-derivatives/gradient-and-directional-derivatives/v/gradient" rel="noopener noreferrer" target="_blank">
            gradients
           </a>
          </li>
          <li>
           And finally, using
           <a href="https://www.khanacademy.org/math/ap-calculus-ab/product-quotient-chain-rules-ab/chain-rule-ab/v/chain-rule-introduction" rel="noopener noreferrer" target="_blank">
            the chain rule
           </a>
          </li>
         </ul>
         <h4 id="continuing-on">
          Continuing on
         </h4>
         <p>
          Multiplying these gradients is just an application of the chain rule:
         </p>
        </div>
       </div>
       <div class="divider">
       </div>
       <div class="ud-atom">
        <h3>
        </h3>
        <div>
         <figure class="figure">
          <img alt="" class="img img-fluid" src="img/dcdw2-chain.png"/>
          <figcaption class="figure-caption">
          </figcaption>
         </figure>
        </div>
       </div>
       <div class="divider">
       </div>
       <div class="ud-atom">
        <h3>
        </h3>
        <div>
         <p>
          You can see in the graph
          <span class="mathquill ud-math">
           w_2
          </span>
          ,
          <span class="mathquill ud-math">
           l_2
          </span>
          , and
          <span class="mathquill ud-math">
           C
          </span>
          are chained together. Any change in
          <span class="mathquill ud-math">
           w_2
          </span>
          will create a change in
          <span class="mathquill ud-math">
           l_2
          </span>
          and the size of that change is given by the gradient
          <span class="mathquill ud-math">
           \partial l_2 / \partial w_2
          </span>
          . Now, since
          <span class="mathquill ud-math">
           l_2
          </span>
          is changing this will cause a change in the cost
          <span class="mathquill ud-math">
           C
          </span>
          and the size of that change is given by the gradient
          <span class="mathquill ud-math">
           \partial C / \partial l_2
          </span>
          . You can think of the chain rule similarly to the domino effect, changing something in the network will propagate through it altering other nodes along the way.
         </p>
        </div>
       </div>
       <div class="divider">
       </div>
       <div class="ud-atom">
        <h3>
        </h3>
        <div>
         <p>
          If you think of the chain rule as normal fractions, you can see that
          <span class="mathquill ud-math">
           \partial l_2
          </span>
          in the denominator and numerator cancel out and you get back
          <span class="mathquill ud-math">
           \partial C / \partial w_2
          </span>
          (although it doesn't exactly work like normal fractions, but it helps to keep track of things.) Okay, let's work out the gradient for
          <span class="mathquill ud-math">
           w_2
          </span>
          . First, we need to know the gradient for
          <span class="mathquill ud-math">
           l_2
          </span>
          .
         </p>
         <p>
          As a reminder
          <a href="https://classroom.udacity.com/nanodegrees/nd101/parts/2a9dba0b-28eb-4b0e-acfa-bdcf35680d90/modules/269a4aad-9025-4354-a0ea-2623e889540a/lessons/b6deebe4-7f78-4947-b2c6-fc660ca942fb/concepts/60049bb7-bdf9-44bc-a6bc-6c8679b62de7" rel="noopener noreferrer" target="_blank">
           the cost
          </a>
          is
         </p>
        </div>
       </div>
       <div class="divider">
       </div>
       <div class="ud-atom">
        <h3>
        </h3>
        <div>
         <figure class="figure">
          <img alt="" class="img img-fluid" src="img/cost.png"/>
          <figcaption class="figure-caption">
          </figcaption>
         </figure>
        </div>
       </div>
       <div class="divider">
       </div>
       <div class="ud-atom">
        <h3>
        </h3>
        <div>
         <p>
          And the value for the second linear node is
         </p>
        </div>
       </div>
       <div class="divider">
       </div>
       <div class="ud-atom">
        <h3>
        </h3>
        <div>
         <figure class="figure">
          <img alt="" class="img img-fluid" src="img/l2.png"/>
          <figcaption class="figure-caption">
          </figcaption>
         </figure>
        </div>
       </div>
       <div class="divider">
       </div>
       <div class="ud-atom">
        <h3>
        </h3>
        <div>
         <p>
          where
          <span class="mathquill ud-math">
           w_2
          </span>
          ,
          <span class="mathquill ud-math">
           s
          </span>
          , and
          <span class="mathquill ud-math">
           b_2
          </span>
          are all vectors and
          <span class="mathquill ud-math">
           w_2 \cdot s
          </span>
          means the dot product of
          <span class="mathquill ud-math">
           w_2
          </span>
          and
          <span class="mathquill ud-math">
           s
          </span>
          .
         </p>
        </div>
       </div>
       <div class="divider">
       </div>
       <div class="ud-atom">
        <h3>
        </h3>
        <div>
         <figure class="figure">
          <img alt="" class="img img-fluid" src="img/dcdl2-grad-fixed.gif"/>
          <figcaption class="figure-caption">
          </figcaption>
         </figure>
        </div>
       </div>
       <div class="divider">
       </div>
       <div class="ud-atom">
        <h3>
        </h3>
        <div>
         <figure class="figure">
          <img alt="" class="img img-fluid" src="img/dl2dw2-grad.png"/>
          <figcaption class="figure-caption">
          </figcaption>
         </figure>
        </div>
       </div>
       <div class="divider">
       </div>
       <div class="ud-atom">
        <h3>
        </h3>
        <div>
         <p>
          And putting these together, you get the gradient for
          <span class="mathquill ud-math">
           w_2
          </span>
         </p>
        </div>
       </div>
       <div class="divider">
       </div>
       <div class="ud-atom">
        <h3>
        </h3>
        <div>
         <figure class="figure">
          <img alt="" class="img img-fluid" src="img/dcdw2-grad-fixed.gif"/>
          <figcaption class="figure-caption">
          </figcaption>
         </figure>
        </div>
       </div>
       <div class="divider">
       </div>
       <div class="ud-atom">
        <h3>
        </h3>
        <div>
         <p>
          This is the gradient you use in the gradient descent update for
          <span class="mathquill ud-math">
           w_2
          </span>
          . You can see what we did here, we walked back through the graph and multiplied all the gradients we found along the way.
         </p>
        </div>
       </div>
       <div class="divider">
       </div>
       <div class="ud-atom">
        <h3>
        </h3>
        <div>
         <p>
          Now, let's go deeper and calculate the gradient for
          <span class="mathquill ud-math">
           w_1
          </span>
          . Here we use the same method as before, walking backwards through the graph.
         </p>
        </div>
       </div>
       <div class="divider">
       </div>
       <div class="ud-atom">
        <h3>
        </h3>
        <div>
         <figure class="figure">
          <img alt="" class="img img-fluid" src="img/w1-backprop-graph.png"/>
          <figcaption class="figure-caption">
          </figcaption>
         </figure>
        </div>
       </div>
       <div class="divider">
       </div>
       <div class="ud-atom">
        <h3>
        </h3>
        <div>
         <p>
          Hopefully it's clear now how to write out the gradient for
          <span class="mathquill ud-math">
           w_1
          </span>
          just by looking at the graph. Using the chain rule, we'll write out the gradients for each node going backwards through the graph until we get to
          <span class="mathquill ud-math">
           w_1
          </span>
          .
         </p>
        </div>
       </div>
       <div class="divider">
       </div>
       <div class="ud-atom">
        <h3>
        </h3>
        <div>
         <figure class="figure">
          <img alt="" class="img img-fluid" src="img/dcdw1-chain.png"/>
          <figcaption class="figure-caption">
          </figcaption>
         </figure>
        </div>
       </div>
       <div class="divider">
       </div>
       <div class="ud-atom">
        <h3>
        </h3>
        <div>
         <p>
          Now we can start calculating each gradient in this expression to get the gradient for
          <span class="mathquill ud-math">
           w_1
          </span>
         </p>
        </div>
       </div>
       <div class="divider">
       </div>
       <div class="ud-atom">
        <h3>
        </h3>
        <div>
         <figure class="figure">
          <img alt="" class="img img-fluid" src="img/dl2ds-grad.png"/>
          <figcaption class="figure-caption">
          </figcaption>
         </figure>
        </div>
       </div>
       <div class="divider">
       </div>
       <div class="ud-atom">
        <h3>
        </h3>
        <div>
         <p>
          The next part is the gradient of the sigmoid function,
          <span class="mathquill ud-math">
           s = f(l_1)
          </span>
          . Since we're using the logistic function here, the derivative can be written in terms of the sigmoid itself
         </p>
        </div>
       </div>
       <div class="divider">
       </div>
       <div class="ud-atom">
        <h3>
        </h3>
        <div>
         <figure class="figure">
          <img alt="" class="img img-fluid" src="img/dsdl1.png"/>
          <figcaption class="figure-caption">
          </figcaption>
         </figure>
        </div>
       </div>
       <div class="divider">
       </div>
       <div class="ud-atom">
        <h3>
        </h3>
        <div>
         <figure class="figure">
          <img alt="" class="img img-fluid" src="img/dl1dw1-grad.png"/>
          <figcaption class="figure-caption">
          </figcaption>
         </figure>
        </div>
       </div>
       <div class="divider">
       </div>
       <div class="ud-atom">
        <h3>
        </h3>
        <div>
         <p>
          Putting this all together, you get
         </p>
        </div>
       </div>
       <div class="divider">
       </div>
       <div class="ud-atom">
        <h3>
        </h3>
        <div>
         <figure class="figure">
          <img alt="" class="img img-fluid" src="img/dcdw1-grad-fixed.gif"/>
          <figcaption class="figure-caption">
          </figcaption>
         </figure>
        </div>
       </div>
       <div class="divider">
       </div>
       <div class="ud-atom">
        <h3>
        </h3>
        <div>
         <p>
          Now we can see a clear pattern. To find the gradient, you just multiply the gradients for all nodes in front of it going backwards from the cost. This is the idea behind
          <strong>
           backpropagation
          </strong>
          . The gradients are passed backwards through the network and used with gradient descent to update the weights and biases. If a node has multiple outgoing nodes, you just sum up the gradients from each node.
         </p>
         <h3 id="implementing-in-miniflow">
          Implementing in MiniFlow
         </h3>
         <p>
          Let's think about how to translate this into MiniFlow. Looking at the graph, you see that each node gets the cost gradient from it's outbound nodes. For example, the node
          <span class="mathquill ud-math">
           l_1
          </span>
          gets
          <span class="mathquill ud-math">
           \partial C / \partial l_1
          </span>
          through the sigmoid node,
          <span class="mathquill ud-math">
           s
          </span>
          . Then
          <span class="mathquill ud-math">
           l_1
          </span>
          passes on the cost gradient to the weight node
          <span class="mathquill ud-math">
           w_1
          </span>
          , but multiplied by
          <span class="mathquill ud-math">
           \partial l_1 / \partial w_1
          </span>
          , the gradient of
          <span class="mathquill ud-math">
           l_1
          </span>
          with respect to it's input
          <span class="mathquill ud-math">
           w_1
          </span>
          .
         </p>
         <p>
          So, each node will pass on the cost gradient to its inbound nodes and each node will get the cost gradient from it's outbound nodes. Then, for each node we'll need to calculate a gradient that's the cost gradient times the gradient of that node with respect to its inputs. Below I've written out this process for a
          <code>
           Linear
          </code>
          node.
         </p>
         <pre><code class="python language-python"># Initialize a partial for each of the inbound_nodes.
self.gradients = {n: np.zeros_like(n.value) for n in self.inbound_nodes}
# Cycle through the outputs. The gradient will change depending
# on each output, so the gradients are summed over all outputs.
for n in self.outbound_nodes:
    # Get the partial of the cost with respect to this node.
    grad_cost = n.gradients[self]
    # Set the partial of the loss with respect to this node's inputs.
    self.gradients[self.inbound_nodes[0]] += np.dot(grad_cost, self.inbound_nodes[1].value.T)
    # Set the partial of the loss with respect to this node's weights.
    self.gradients[self.inbound_nodes[1]] += np.dot(self.inbound_nodes[0].value.T, grad_cost)
    # Set the partial of the loss with respect to this node's bias.
    self.gradients[self.inbound_nodes[2]] += np.sum(grad_cost, axis=0, keepdims=False)</code></pre>
        </div>
       </div>
       <div class="divider">
       </div>
       <div class="ud-atom">
        <h3>
        </h3>
        <div>
         <h3 id="new-code">
          New Code
         </h3>
         <p>
          There have been a couple of changes to MiniFlow since we last took it for a spin:
         </p>
         <p>
          The first being the
          <code>
           Node
          </code>
          class now has a
          <code>
           backward
          </code>
          method, as well as a new attribute
          <code>
           self.gradients
          </code>
          , which is used to store and cache gradients during the backward pass.
         </p>
         <pre><code class="python language-python">class Node(object):
    """
    Base class for nodes in the network.

    Arguments:

        `inbound_nodes`: A list of nodes with edges into this node.
    """
    def __init__(self, inbound_nodes=[]):
        """
        Node's constructor (runs when the object is instantiated). Sets
        properties that all nodes need.
        """
        # A list of nodes with edges into this node.
        self.inbound_nodes = inbound_nodes
        # The eventual value of this node. Set by running
        # the forward() method.
        self.value = None
        # A list of nodes that this node outputs to.
        self.outbound_nodes = []
        # New property! Keys are the inputs to this node and
        # their values are the partials of this node with
        # respect to that input.
        self.gradients = {}
        # Sets this node as an outbound node for all of
        # this node's inputs.
        for node in inbound_nodes:
            node.outbound_nodes.append(self)

    def forward(self):
        """
        Every node that uses this class as a base class will
        need to define its own `forward` method.
        """
        raise NotImplementedError

    def backward(self):
        """
        Every node that uses this class as a base class will
        need to define its own `backward` method.
        """
        raise NotImplementedError</code></pre>
         <p>
          The second change is to the helper function
          <code>
           forward_pass()
          </code>
          . That function has been replaced with
          <code>
           forward_and_backward()
          </code>
          .
         </p>
         <pre><code class="python language-python">def forward_and_backward(graph):
    """
    Performs a forward pass and a backward pass through a list of sorted nodes.

    Arguments:

        `graph`: The result of calling `topological_sort`.
    """
    # Forward pass
    for n in graph:
        n.forward()

    # Backward pass
    # see: https://docs.python.org/2.3/whatsnew/section-slices.html
    for n in graph[::-1]:
        n.backward()</code></pre>
        </div>
       </div>
       <div class="divider">
       </div>
       <div class="ud-atom">
        <h3>
        </h3>
        <div>
         <h3 id="setup">
          Setup
         </h3>
         <p>
          Here's the derivative of the
          <span class="mathquill ud-math">
           sigmoid
          </span>
          function w.r.t
          <span class="mathquill ud-math">
           x
          </span>
          :
         </p>
         <p>
          <span class="mathquill ud-math">
           sigmoid(x) = 1 / (1 + exp(-x))
          </span>
         </p>
         <p>
          <span class="mathquill ud-math">
           \frac {\partial sigmoid}{\partial x} = sigmoid(x) * (1 - sigmoid(x))
          </span>
         </p>
         <ul>
          <li>
           Complete the implementation of backpropagation for the
           <code>
            Sigmoid
           </code>
           node by finishing the
           <code>
            backward
           </code>
           method in
           <code>
            miniflow.py
           </code>
           .
          </li>
          <li>
           The
           <code>
            backward
           </code>
           methods for all other nodes have already been implemented. Taking a look at them might be helpful.
          </li>
         </ul>
        </div>
       </div>
       <div class="divider">
       </div>
       <div class="ud-atom">
        <h3>
        </h3>
        <div>
         <h4>
          Start Quiz:
         </h4>
         <div>
          <div class="nav nav-tabs nav-fill" id="question-tabs" role="tablist">
           <a aria-controls="264116-nn-py" aria-selected="true" class="nav-item nav-link active show" data-toggle="tab" href="#264116-nn-py" id="tab-264116-nn-py" role="tab">
            nn.py
           </a>
           <a aria-controls="264116-miniflow-py" aria-selected="false" class="nav-item nav-link" data-toggle="tab" href="#264116-miniflow-py" id="tab-264116-miniflow-py" role="tab">
            miniflow.py
           </a>
          </div>
          <div class="tab-content" id="question-tab-contents" style="padding: 20px 0;">
           <div aria-labelledby="tab-264116-nn-py" class="tab-pane active show" id="264116-nn-py" role="tabpanel">
            <pre><code></code>"""
Test your network here!

No need to change this code, but feel free to tweak it
to test your network!

Make your changes to backward method of the Sigmoid class in miniflow.py
"""

import numpy as np
from miniflow import *

X, W, b = Input(), Input(), Input()
y = Input()
f = Linear(X, W, b)
a = Sigmoid(f)
cost = MSE(y, a)

X_ = np.array([[-1., -2.], [-1, -2]])
W_ = np.array([[2.], [3.]])
b_ = np.array([-3.])
y_ = np.array([1, 2])

feed_dict = {
    X: X_,
    y: y_,
    W: W_,
    b: b_,
}

graph = topological_sort(feed_dict)
forward_and_backward(graph)
# return the gradients for each Input
gradients = [t.gradients[t] for t in [X, y, W, b]]

"""
Expected output

[array([[ -3.34017280e-05,  -5.01025919e-05],
       [ -6.68040138e-05,  -1.00206021e-04]]), array([[ 0.9999833],
       [ 1.9999833]]), array([[  5.01028709e-05],
       [  1.00205742e-04]]), array([ -5.01028709e-05])]
"""
print(gradients)
</pre>
           </div>
           <div aria-labelledby="tab-264116-miniflow-py" class="tab-pane" id="264116-miniflow-py" role="tabpanel">
            <pre><code></code>"""
Implement the backward method of the Sigmoid node.
"""
import numpy as np


class Node(object):
    """
    Base class for nodes in the network.

    Arguments:

        `inbound_nodes`: A list of nodes with edges into this node.
    """
    def __init__(self, inbound_nodes=[]):
        """
        Node's constructor (runs when the object is instantiated). Sets
        properties that all nodes need.
        """
        # A list of nodes with edges into this node.
        self.inbound_nodes = inbound_nodes
        # The eventual value of this node. Set by running
        # the forward() method.
        self.value = None
        # A list of nodes that this node outputs to.
        self.outbound_nodes = []
        # New property! Keys are the inputs to this node and
        # their values are the partials of this node with
        # respect to that input.
        self.gradients = {}
        # Sets this node as an outbound node for all of
        # this node's inputs.
        for node in inbound_nodes:
            node.outbound_nodes.append(self)

    def forward(self):
        """
        Every node that uses this class as a base class will
        need to define its own `forward` method.
        """
        raise NotImplementedError

    def backward(self):
        """
        Every node that uses this class as a base class will
        need to define its own `backward` method.
        """
        raise NotImplementedError


class Input(Node):
    """
    A generic input into the network.
    """
    def __init__(self):
        # The base class constructor has to run to set all
        # the properties here.
        #
        # The most important property on an Input is value.
        # self.value is set during `topological_sort` later.
        Node.__init__(self)

    def forward(self):
        # Do nothing because nothing is calculated.
        pass

    def backward(self):
        # An Input node has no inputs so the gradient (derivative)
        # is zero.
        # The key, `self`, is reference to this object.
        self.gradients = {self: 0}
        # Weights and bias may be inputs, so you need to sum
        # the gradient from output gradients.
        for n in self.outbound_nodes:
            grad_cost = n.gradients[self]
            self.gradients[self] += grad_cost * 1


class Linear(Node):
    """
    Represents a node that performs a linear transform.
    """
    def __init__(self, X, W, b):
        # The base class (Node) constructor. Weights and bias
        # are treated like inbound nodes.
        Node.__init__(self, [X, W, b])

    def forward(self):
        """
        Performs the math behind a linear transform.
        """
        X = self.inbound_nodes[0].value
        W = self.inbound_nodes[1].value
        b = self.inbound_nodes[2].value
        self.value = np.dot(X, W) + b

    def backward(self):
        """
        Calculates the gradient based on the output values.
        """
        # Initialize a partial for each of the inbound_nodes.
        self.gradients = {n: np.zeros_like(n.value) for n in self.inbound_nodes}
        # Cycle through the outputs. The gradient will change depending
        # on each output, so the gradients are summed over all outputs.
        for n in self.outbound_nodes:
            # Get the partial of the cost with respect to this node.
            grad_cost = n.gradients[self]
            # Set the partial of the loss with respect to this node's inputs.
            self.gradients[self.inbound_nodes[0]] += np.dot(grad_cost, self.inbound_nodes[1].value.T)
            # Set the partial of the loss with respect to this node's weights.
            self.gradients[self.inbound_nodes[1]] += np.dot(self.inbound_nodes[0].value.T, grad_cost)
            # Set the partial of the loss with respect to this node's bias.
            self.gradients[self.inbound_nodes[2]] += np.sum(grad_cost, axis=0, keepdims=False)


class Sigmoid(Node):
    """
    Represents a node that performs the sigmoid activation function.
    """
    def __init__(self, node):
        # The base class constructor.
        Node.__init__(self, [node])

    def _sigmoid(self, x):
        """
        This method is separate from `forward` because it
        will be used with `backward` as well.

        `x`: A numpy array-like object.
        """
        return 1. / (1. + np.exp(-x))

    def forward(self):
        """
        Perform the sigmoid function and set the value.
        """
        input_value = self.inbound_nodes[0].value
        self.value = self._sigmoid(input_value)

    def backward(self):
        """
        Calculates the gradient using the derivative of
        the sigmoid function.
        """
        # Initialize the gradients to 0.
        self.gradients = {n: np.zeros_like(n.value) for n in self.inbound_nodes}

        # Cycle through the outputs. The gradient will change depending
        # on each output, so the gradients are summed over all outputs.
        for n in self.outbound_nodes:
            # Get the partial of the cost with respect to this node.
            grad_cost = n.gradients[self]
            """
            TODO: Your code goes here!

            Set the gradients property to the gradients with respect to each input.

            NOTE: See the Linear node and MSE node for examples.
            """


class MSE(Node):
    def __init__(self, y, a):
        """
        The mean squared error cost function.
        Should be used as the last node for a network.
        """
        # Call the base class' constructor.
        Node.__init__(self, [y, a])

    def forward(self):
        """
        Calculates the mean squared error.
        """
        # NOTE: We reshape these to avoid possible matrix/vector broadcast
        # errors.
        #
        # For example, if we subtract an array of shape (3,) from an array of shape
        # (3,1) we get an array of shape(3,3) as the result when we want
        # an array of shape (3,1) instead.
        #
        # Making both arrays (3,1) insures the result is (3,1) and does
        # an elementwise subtraction as expected.
        y = self.inbound_nodes[0].value.reshape(-1, 1)
        a = self.inbound_nodes[1].value.reshape(-1, 1)

        self.m = self.inbound_nodes[0].value.shape[0]
        # Save the computed output for backward.
        self.diff = y - a
        self.value = np.mean(self.diff**2)

    def backward(self):
        """
        Calculates the gradient of the cost.

        This is the final node of the network so outbound nodes
        are not a concern.
        """
        self.gradients[self.inbound_nodes[0]] = (2 / self.m) * self.diff
        self.gradients[self.inbound_nodes[1]] = (-2 / self.m) * self.diff


def topological_sort(feed_dict):
    """
    Sort the nodes in topological order using Kahn's Algorithm.

    `feed_dict`: A dictionary where the key is a `Input` Node and the value is the respective value feed to that Node.

    Returns a list of sorted nodes.
    """

    input_nodes = [n for n in feed_dict.keys()]

    G = {}
    nodes = [n for n in input_nodes]
    while len(nodes) &gt; 0:
        n = nodes.pop(0)
        if n not in G:
            G[n] = {'in': set(), 'out': set()}
        for m in n.outbound_nodes:
            if m not in G:
                G[m] = {'in': set(), 'out': set()}
            G[n]['out'].add(m)
            G[m]['in'].add(n)
            nodes.append(m)

    L = []
    S = set(input_nodes)
    while len(S) &gt; 0:
        n = S.pop()

        if isinstance(n, Input):
            n.value = feed_dict[n]

        L.append(n)
        for m in n.outbound_nodes:
            G[n]['out'].remove(m)
            G[m]['in'].remove(n)
            # if no other incoming edges add to S
            if len(G[m]['in']) == 0:
                S.add(m)
    return L


def forward_and_backward(graph):
    """
    Performs a forward pass and a backward pass through a list of sorted Nodes.

    Arguments:

        `graph`: The result of calling `topological_sort`.
    """
    # Forward pass
    for n in graph:
        n.forward()

    # Backward pass
    # see: https://docs.python.org/2.3/whatsnew/section-slices.html
    for n in graph[::-1]:
        n.backward()
</pre>
           </div>
          </div>
         </div>
        </div>
       </div>
       <div class="divider">
       </div>
      </div>
      <div class="col-12">
       <p class="text-right">
        <a class="btn btn-outline-primary mt-4" href="13. Stochastic Gradient Descent.html" role="button">
         Next Concept
        </a>
       </p>
      </div>
     </div>
    </main>
    <footer class="footer">
     <div class="container">
      <div class="row">
       <div class="col-12">
        <p class="text-center">
         udacity2.0 If you need the newest courses Plase add me wechat: udacity6
        </p>
       </div>
      </div>
     </div>
    </footer>
   </div>
  </div>
  <script src="../assets/js/jquery-3.3.1.min.js">
  </script>
  <script src="../assets/js/plyr.polyfilled.min.js">
  </script>
  <script src="../assets/js/bootstrap.min.js">
  </script>
  <script src="../assets/js/jquery.mCustomScrollbar.concat.min.js">
  </script>
  <script src="../assets/js/katex.min.js">
  </script>
  <script>
   // Initialize Plyr video players
    const players = Array.from(document.querySelectorAll('video')).map(p => new Plyr(p));

    // render math equations
    let elMath = document.getElementsByClassName('mathquill');
    for (let i = 0, len = elMath.length; i < len; i += 1) {
      const el = elMath[i];

      katex.render(el.textContent, el, {
        throwOnError: false
      });
    }

    // this hack will make sure Bootstrap tabs work when using Handlebars
    if ($('#question-tabs').length && $('#user-answer-tabs').length) {
      $("#question-tabs a.nav-link").on('click', function () {
        $("#question-tab-contents .tab-pane").hide();
        $($(this).attr("href")).show();
      });
      $("#user-answer-tabs a.nav-link").on('click', function () {
        $("#user-answer-tab-contents .tab-pane").hide();
        $($(this).attr("href")).show();
      });
    } else {
      $("a.nav-link").on('click', function () {
        $(".tab-pane").hide();
        $($(this).attr("href")).show();
      });
    }

    // side bar events
    $(document).ready(function () {
      $("#sidebar").mCustomScrollbar({
        theme: "minimal"
      });

      $('#sidebarCollapse').on('click', function () {
        $('#sidebar, #content').toggleClass('active');
        $('.collapse.in').toggleClass('in');
        $('a[aria-expanded=true]').attr('aria-expanded', 'false');
      });

      // scroll to first video on page loading
      if ($('video').length) {
        $('html,body').animate({ scrollTop: $('div.plyr').prev().offset().top});
      }

      // auto play first video: this may not work with chrome/safari due to autoplay policy
      if (players && players.length > 0) {
        players[0].play();
      }

      // scroll sidebar to current concept
      const currentInSideBar = $( "ul.sidebar-list.components li a:contains('12. Backpropagation')" )
      currentInSideBar.css( "text-decoration", "underline" );
      $("#sidebar").mCustomScrollbar('scrollTo', currentInSideBar);
    });
  </script>
 </body>
</html>
